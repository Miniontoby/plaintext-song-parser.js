{"version":3,"file":"plaintext-song-parser.min.js","sources":["../src/index.ts"],"sourcesContent":["export default class Song {\r\n\tcontent: string = '';\r\n\tidentifier: number|string|null = null;\r\n\ttitle: string|null = null;\r\n\tcouplets: string[][] = [];\r\n\tcoupletsWithReferences: string[][] = [];\r\n\tmodifiers: {title?: string}&any = {};\r\n\tconstructor(content: string[]|string, identifier: number|string|null = null, title: string|null = null) {\r\n\t\tif (identifier) {\r\n\t\t\tthis.identifier = Number(identifier);\r\n\t\t\tif (isNaN(this.identifier)) this.identifier = identifier;\r\n\t\t}\r\n\t\tif (content && content !== '') {\r\n\t\t\tif (typeof (content) == 'string') this.content = content;\r\n\t\t\telse this.content = content.join('\\n');\r\n\t\t}\r\n\t\tif (title && title !== '') this.title = title;\r\n\t\tif (this.content) {\r\n\t\t\tthis.modifiers = Song.getModifiersFromText(this.getLines(true));\r\n\t\t\tif (this.title === null && this.modifiers?.title) this.title = this.modifiers.title;\r\n\t\t\tthis.process();\r\n\t\t}\r\n\t}\r\n\tget lines(): string[]|null {\r\n\t\treturn this.getLines();\r\n\t}\r\n\tprivate getLines(returnComments = false): string[]|null {\r\n\t\tconst allLines = this.content?.split(/\\r?\\n/);\r\n\t\tif (!allLines) return null;\r\n\t\tconst firstNonCommentIndex = allLines.findIndex(line => !line.startsWith('#'));\r\n\t\tif (returnComments) return allLines.slice(0, firstNonCommentIndex > -1 ? firstNonCommentIndex : undefined); // +1 cause this is exclusive of the element at the index 'end'\r\n\t\telse return allLines.slice(firstNonCommentIndex);\r\n\t}\r\n\tprocess(): void {\r\n\t\tif (!this.lines) return;\r\n\r\n\t\tconst paragraphs1 = this.lines.join('\\n').split('\\n\\n'); // split the paragraphs\r\n\t\tlet paragraphs = paragraphs1.map((al) => [al]); // map the paragraphs in seperate arrays\r\n\t\tparagraphs = paragraphs.map((al) => al[0].split('[split]\\n')); // split the paragraphs on the keyword: '[split]'\r\n\t\tconst lastPart = paragraphs[paragraphs.length - 1],lastAl = lastPart[lastPart.length - 1]; // get the last array of the last paragraph\r\n\t\tif (lastAl.endsWith('\\n')) paragraphs[paragraphs.length - 1][lastPart.length - 1] = lastAl.slice(0, -1); // Make sure to remove the linebreak of the last paragraph, else some statements will fail\r\n\t\tconst parts = paragraphs.map((al, i) => {\r\n\t\t\tif (al[0].split('\\n')[0].endsWith(':') && al[0].split('\\n')[0].split(' ').length == 1) return [i, al];\r\n\t\t\treturn null;\r\n\t\t}).filter((x): x is [number, string[]] => x !== null); // filter all paragraphs that end on ':' and that contain no spaces\r\n\t\tconst blockNames = parts.map((al) => [al[0], al[1][0].split('\\n')[0].replace(':', '')]); // get the reference names from the parts array\r\n\t\tconst blockContents = parts.map((al) => { const lines = al[1][0].split('\\n'); lines.splice(0,1); al[1][0] = lines.join('\\n'); return al[1]; }); // get the contents of them, by removing the first line of the paragraph out of the parts array\r\n\t\tconst blocks = blockNames.map((name, i) => [name[0], name[1], blockContents[i]]); // combine the two arrays into 1 array in the format: [id, 'name', 'content']\r\n\t\tlet blockUsage = paragraphs.map((al, i) => {\r\n\t\t\tconst p = al[0].split('\\n');\r\n\t\t\tif (al.length > 1 || p.length > 1) return null;\r\n\t\t\tconst myBlockNames = blockNames.map(a=>a[1]);\r\n\t\t\tif (myBlockNames.includes(p[0]) || myBlockNames.includes(p[0].replace('Repeat ', '')) || myBlockNames.includes(p[0].replace(/\\(([\\w]+)( (\\d+)x|)\\)/, '$1'))) return [i, p[0]];\r\n\t\t\treturn null;\r\n\t\t}).filter((x): x is [number, string] => x !== null); // filter the paragraphs that include an reference to an existing reference\r\n\t\tblockUsage = blockUsage.map((us) => [us[0], us[1].replace('Repeat ', '').replace(/\\((\\w+)( (\\d+)x|)\\)/, '$1$2')]); // Remove 'Repeat ' keyword from the text and the '(key)' and '(key 2x)' keywords\r\n\t\tconst blockUsing = blockUsage.map((us)=>{\r\n\t\t\tconst ourid = us[1].replace(/ (\\d+)x/, '');\r\n\t\t\tconst amount = Number(us[1].replace(/(\\w+)( (\\d+)x|)/, '$3')) || 1;\r\n\t\t\tconst out = blocks.find((bl) => bl[1] == ourid);\r\n\t\t\tif (!out) return;\r\n\t\t\treturn [us[0], ourid, amount, out[2]]; // [index inside paragraphs, blockName, amount of repeats, text]\r\n\t\t}).filter((x): x is [number, string, number, string[]] => x !== null);\r\n\r\n\t\tthis.coupletsWithReferences = JSON.parse(JSON.stringify(paragraphs));\r\n\t\tfor (const [index, blockName, amount, text] of blockUsing) {\r\n\t\t\tparagraphs[index] = text; // replace the contents of the paragraph with the contents of the reference\r\n\t\t\tfor (let i=1;i<amount;i++) paragraphs[index] = [...paragraphs[index], ...text]; // repeat adding in the contents for the amount\r\n\t\t}\r\n\t\tthis.couplets = paragraphs;\r\n\t}\r\n\tstatic getTitleFromText(content: string[]|string): string|null {\r\n\t\tconst modifiers = Song.getModifiersFromText(content);\r\n\t\treturn modifiers?.title ?? null;\r\n\t}\r\n\tstatic getModifiersFromText(content: string[]|string): {title: string}&any {\r\n\t\tconst lines = (typeof (content) == 'string') ? content.split(/\\r?\\n/) : content;\r\n\t\tif (lines === null || lines === undefined) return {};\r\n\t\tconst firstNonCommentIndex = lines?.findIndex(line => !line.startsWith('#'));\r\n\t\tconst comments = lines.slice(0, firstNonCommentIndex > -1 ? firstNonCommentIndex : undefined);\r\n\t\tconst modifiers = {};\r\n\t\tfor (let comment of comments) {\r\n\t\t\tcomment = comment.replace(/^#\\s*/, ''); // Remove comment prefix\r\n\t\t\tconst regex = /^([\\w]+)\\s*=\\s*(.*)$/;\r\n\t\t\tconst m = regex.exec(comment);\r\n\t\t\tif (m) {\r\n\t\t\t\tmodifiers[m[1]] = m[2];\r\n\t\t\t\tif (m[2] === 'true') modifiers[m[1]] = true;\r\n\t\t\t\telse if (m[2] === 'false') modifiers[m[1]] = false;\r\n\t\t\t\telse if (!isNaN(Number(m[2]))) modifiers[m[1]] = Number(m[2]);\r\n\t\t\t} else if (!comment.includes('=')) {\r\n\t\t\t\tmodifiers['title'] = comment;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn modifiers;\r\n\t}\r\n}"],"names":["Song","constructor","content","identifier","title","this","couplets","coupletsWithReferences","modifiers","Number","isNaN","join","getModifiersFromText","getLines","process","lines","returnComments","allLines","split","firstNonCommentIndex","findIndex","line","startsWith","slice","undefined","paragraphs","map","al","lastPart","length","lastAl","endsWith","parts","i","filter","x","blockNames","replace","blockContents","splice","blocks","name","blockUsage","p","myBlockNames","a","includes","us","blockUsing","ourid","amount","out","find","bl","JSON","parse","stringify","index","blockName","text","getTitleFromText","comments","comment","m","exec"],"mappings":"qOAAc,MAAOA,EAOpB,WAAAC,CAAYC,EAA0BC,EAAiC,KAAMC,EAAqB,MANlGC,KAAOH,QAAW,GAClBG,KAAUF,WAAuB,KACjCE,KAAKD,MAAgB,KACrBC,KAAQC,SAAe,GACvBD,KAAsBE,uBAAe,GACrCF,KAASG,UAAyB,GAE7BL,IACHE,KAAKF,WAAaM,OAAON,GACrBO,MAAML,KAAKF,cAAaE,KAAKF,WAAaA,IAE3CD,GAAuB,KAAZA,IACoBG,KAAKH,QAAf,iBAApB,EAA6CA,EAC7BA,EAAQS,KAAK,OAE9BP,GAAmB,KAAVA,IAAcC,KAAKD,MAAQA,GACpCC,KAAKH,UACRG,KAAKG,UAAYR,EAAKY,qBAAqBP,KAAKQ,UAAS,IACtC,OAAfR,KAAKD,OAAkBC,KAAKG,WAAWJ,QAAOC,KAAKD,MAAQC,KAAKG,UAAUJ,OAC9EC,KAAKS,UAEN,CACD,SAAIC,GACH,OAAOV,KAAKQ,UACZ,CACO,QAAAA,CAASG,GAAiB,GACjC,MAAMC,EAAWZ,KAAKH,SAASgB,MAAM,SACrC,IAAKD,EAAU,OAAO,KACtB,MAAME,EAAuBF,EAASG,WAAUC,IAASA,EAAKC,WAAW,OACzE,OAAIN,EAAuBC,EAASM,MAAM,EAAGJ,GAAwB,EAAIA,OAAuBK,GACpFP,EAASM,MAAMJ,EAC3B,CACD,OAAAL,GACC,IAAKT,KAAKU,MAAO,OAGjB,IAAIU,EADgBpB,KAAKU,MAAMJ,KAAK,MAAMO,MAAM,QACnBQ,KAAKC,GAAO,CAACA,KAC1CF,EAAaA,EAAWC,KAAKC,GAAOA,EAAG,GAAGT,MAAM,eAChD,MAAMU,EAAWH,EAAWA,EAAWI,OAAS,GAAGC,EAASF,EAASA,EAASC,OAAS,GACnFC,EAAOC,SAAS,QAAON,EAAWA,EAAWI,OAAS,GAAGD,EAASC,OAAS,GAAKC,EAAOP,MAAM,GAAI,IACrG,MAAMS,EAAQP,EAAWC,KAAI,CAACC,EAAIM,IAC7BN,EAAG,GAAGT,MAAM,MAAM,GAAGa,SAAS,MAAkD,GAA1CJ,EAAG,GAAGT,MAAM,MAAM,GAAGA,MAAM,KAAKW,OAAoB,CAACI,EAAGN,GAC3F,OACLO,QAAQC,GAAqC,OAANA,IACpCC,EAAaJ,EAAMN,KAAKC,GAAO,CAACA,EAAG,GAAIA,EAAG,GAAG,GAAGT,MAAM,MAAM,GAAGmB,QAAQ,IAAK,OAC5EC,EAAgBN,EAAMN,KAAKC,IAAS,MAAMZ,EAAQY,EAAG,GAAG,GAAGT,MAAM,MAAuD,OAAhDH,EAAMwB,OAAO,EAAE,GAAIZ,EAAG,GAAG,GAAKZ,EAAMJ,KAAK,MAAcgB,EAAG,EAAE,IACpIa,EAASJ,EAAWV,KAAI,CAACe,EAAMR,IAAM,CAACQ,EAAK,GAAIA,EAAK,GAAIH,EAAcL,MAC5E,IAAIS,EAAajB,EAAWC,KAAI,CAACC,EAAIM,KACpC,MAAMU,EAAIhB,EAAG,GAAGT,MAAM,MACtB,GAAIS,EAAGE,OAAS,GAAKc,EAAEd,OAAS,EAAG,OAAO,KAC1C,MAAMe,EAAeR,EAAWV,KAAImB,GAAGA,EAAE,KACzC,OAAID,EAAaE,SAASH,EAAE,KAAOC,EAAaE,SAASH,EAAE,GAAGN,QAAQ,UAAW,MAAQO,EAAaE,SAASH,EAAE,GAAGN,QAAQ,wBAAyB,OAAe,CAACJ,EAAGU,EAAE,IACnK,IAAI,IACTT,QAAQC,GAAmC,OAANA,IACxCO,EAAaA,EAAWhB,KAAKqB,GAAO,CAACA,EAAG,GAAIA,EAAG,GAAGV,QAAQ,UAAW,IAAIA,QAAQ,sBAAuB,WACxG,MAAMW,EAAaN,EAAWhB,KAAKqB,IAClC,MAAME,EAAQF,EAAG,GAAGV,QAAQ,UAAW,IACjCa,EAASzC,OAAOsC,EAAG,GAAGV,QAAQ,kBAAmB,QAAU,EAC3Dc,EAAMX,EAAOY,MAAMC,GAAOA,EAAG,IAAMJ,IACzC,GAAKE,EACL,MAAO,CAACJ,EAAG,GAAIE,EAAOC,EAAQC,EAAI,GAAG,IACnCjB,QAAQC,GAAqD,OAANA,IAE1D9B,KAAKE,uBAAyB+C,KAAKC,MAAMD,KAAKE,UAAU/B,IACxD,IAAK,MAAOgC,EAAOC,EAAWR,EAAQS,KAASX,EAAY,CAC1DvB,EAAWgC,GAASE,EACpB,IAAK,IAAI1B,EAAE,EAAEA,EAAEiB,EAAOjB,IAAKR,EAAWgC,GAAS,IAAIhC,EAAWgC,MAAWE,EACzE,CACDtD,KAAKC,SAAWmB,CAChB,CACD,uBAAOmC,CAAiB1D,GACvB,MAAMM,EAAYR,EAAKY,qBAAqBV,GAC5C,OAAOM,GAAWJ,OAAS,IAC3B,CACD,2BAAOQ,CAAqBV,GAC3B,MAAMa,EAA6B,iBAAZ,EAAwBb,EAAQgB,MAAM,SAAWhB,EACxE,GAAIa,QAAuC,MAAO,GAClD,MAAMI,EAAuBJ,GAAOK,WAAUC,IAASA,EAAKC,WAAW,OACjEuC,EAAW9C,EAAMQ,MAAM,EAAGJ,GAAwB,EAAIA,OAAuBK,GAC7EhB,EAAY,CAAA,EAClB,IAAK,IAAIsD,KAAWD,EAAU,CAC7BC,EAAUA,EAAQzB,QAAQ,QAAS,IACnC,MACM0B,EADQ,uBACEC,KAAKF,GACjBC,GACHvD,EAAUuD,EAAE,IAAMA,EAAE,GACP,SAATA,EAAE,GAAevD,EAAUuD,EAAE,KAAM,EACrB,UAATA,EAAE,GAAgBvD,EAAUuD,EAAE,KAAM,EACnCrD,MAAMD,OAAOsD,EAAE,OAAMvD,EAAUuD,EAAE,IAAMtD,OAAOsD,EAAE,MAC/CD,EAAQhB,SAAS,OAC5BtC,EAAiB,MAAIsD,EAEtB,CACD,OAAOtD,CACP"}